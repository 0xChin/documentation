---
sidebar_position: 1
id: quickstart
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Quickstart

These are the simplest working contracts that demonstrate how to use `xcall`, a cross-chain primitive mimicking Solidity's low level `call` method.

---

## Setup

Install [Node.js](https://nodejs.dev/en/learn/how-to-install-nodejs/) and use **Node.js v16**. Follow the instructions to install `nvm`, a node version manager, which will make switching versions easier.

Install the latest beta version of Connext contracts package in your project.

```bash npm2yarn
npm install @connext/nxtp-contracts@beta
```

---

## Example 1: Hello Chain

Cross-chain calls can target smart contract functions by sending encoded `calldata`. 

In this example, there are two contracts. The `HelloTarget` contract on the destination domain stores a greeting that we want to update. The `HelloSource` contract on the origin domain will call `xcall` to execute the `_updateGreeting` function on `HelloTarget`.

### Target Contract

The target contract must implement Connext's `IXReceiver` interface. This interface ensures that Connext can call the receiver and pass necessary data. 

```solidity showLineNumbers
pragma solidity ^0.8.15;

import {IXReceiver} from "@nxtp/core/connext/interfaces/IXReceiver.sol";

contract HelloTarget is IXReceiver {
  string public greeting;

  /** @notice The receiver function as required by the IXReceiver interface.
    * @dev The Connext bridge contract will call this function.
    */
  function xReceive(
    bytes32 _transferId,
    uint256 _amount,
    address _asset,
    address _originSender,
    uint32 _origin,
    bytes memory _callData
  ) external returns (bytes memory) {
    // _callData contains encoded data that will be sent from the source contract
    _updateGreeting(_callData);
  }

  /** @notice Internal function to update the greeting.
    * @param _callData Calldata containing the new greeting.
    */
  function _updateGreeting(bytes memory _callData) internal {
    // The _callData is decoded to unpack the new greeting 
    string memory newGreeting = abi.decode(_callData, (string));
    greeting = newGreeting;
  }
}
```

The goal is to call `_updateGreeting` from the origin domain.

### Source Contract

The source contract initiates the cross-chain operation with `xcall` and passes the encoded greeting into the call.

```solidity showLineNumbers
pragma solidity ^0.8.15;

import {IConnext} from "@connext/nxtp-contracts/contracts/core/connext/interfaces/IConnext.sol";

/**
 * @title HelloSource
 * @notice Example of cross-domain messaging.
 */
contract HelloSource {
  // The connext contract on the origin domain.
  IConnext public immutable connext;

  constructor(IConnext _connext) {
    connext = _connext;
  }

  /** @notice Updates a greeting variable on the HelloTarget contract.
    * @param target Address of the HelloTarget contract.
    * @param destinationDomain The destination domain ID.
    * @param newGreeting New greeting to update to.
    * @param relayerFee The fee offered to relayers. On testnet, this can be 0.
    */
  function updateGreeting (
    address target, 
    uint32 destinationDomain,
    string memory newGreeting,
    uint256 relayerFee
  ) external payable {
    // Encode the data needed for the target contract call.
    bytes memory callData = abi.encode(newGreeting);

    connext.xcall{value: relayerFee}(
      destinationDomain, // _destination: Domain ID of the destination chain
      target,            // _to: address of the target contract
      address(0),        // _asset: use address zero for 0-value transfers
      msg.sender,        // _delegate: address that can revert or forceLocal on destination
      0,                 // _amount: 0 because no funds are being transferred
      0,                 // _slippage: can be anything between 0-10000 because no funds are being transferred
      callData           // _callData: the encoded calldata to send
    );
  }
}
```

---

## Example 2: Cross-Chain Transfer

This `XTransfer` contract implements a cross-chain token transfer. There's no target contract on the destination side so only one contract is needed.

### XTransfer Contract

```solidity showLineNumbers
pragma solidity ^0.8.15;

import {IConnext} from "@nxtp/core/connext/interfaces/IConnext.sol";
import {ERC20} from "@solmate/tokens/ERC20.sol";

/**
 * @title XTransfer
 * @notice Example of a cross-domain token transfer.
 */
contract XTransfer {
  // The connext contract on the origin domain.
  IConnext public immutable connext;

  constructor(IConnext _connext) {
    connext = _connext;
  }

  /**
   * @notice Transfers funds from one chain to another.
   * @param recipient The destination address (e.g. a wallet).
   * @param destinationDomain The destination domain ID.
   * @param tokenAddress Address of the token to transfer.
   * @param amount The amount to transfer.
   * @param relayerFee The fee offered to relayers. On testnet, this can be 0.
   */
  function transfer(
    address recipient,
    uint32 destinationDomain,
    address tokenAddress,
    uint256 amount,
    uint256 relayerFee
  ) external payable {
    ERC20 token = ERC20(tokenAddress);
    require(
      token.allowance(msg.sender, address(this)) >= amount,
      "User must approve amount"
    );

    // User sends funds to this contract
    token.transferFrom(msg.sender, address(this), amount);

    // This contract approves transfer to Connext
    token.approve(address(connext), amount);

    connext.xcall{value: relayerFee}(
      destinationDomain, // _destination: Domain ID of the destination chain
      recipient,         // _to: address receiving the funds on the destination
      tokenAddress,      // _asset: address of the token contract
      msg.sender,        // _delegate: address that can revert or forceLocal on destination
      amount,            // _amount: amount of tokens to transfer
      30,                // _slippage: the maximum amount of slippage the user will accept in BPS, in this case 0.3%
      ""                 // _callData: empty because we're only sending funds
    );  
  }
}
```

Since funds are going to be routed through Connext's contracts, the user must first approve a spending allowance of the ERC20 to the `XTransfer` contract. The `require` clause starting on line 34 checks for this allowance. 

If you are using the TEST ERC20 token as the `tokenAddress` for this example, you can use [Etherscan and write](https://goerli.etherscan.io/address/0x7ea6eA49B0b0Ae9c5db7907d139D9Cd3439862a1#writeContract) to the token's `approve` function: 

<img src="/img/developers/TestERC20_Etherscan_Approve.png" alt="TestERC20 Etherscan Approve" width="400"/>

The tokens flow from `User's wallet` => `XTransfer` => `ConnextHandler` => `recipient`.

---

## Next Steps

- Try [tracking the status](../guides/xcall-status) of an `xcall` after you send it.
- Learn about [authentication](./authentication) and important security considerations.
- See how [nested xcalls](./nested-xcalls) can open up infinite cross-chain possibilities.
- Fork the xApp Starter Kit below and build your own xApp.

[xApp Starter Kit](https://github.com/connext/xapp-starter/)
