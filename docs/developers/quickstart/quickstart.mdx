---
sidebar_position: 1
id: quickstart
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Quickstart

These are the simplest working contracts that demonstrate how to use `xcall`, a cross-chain primitive mimicking Solidity's low level `call` method.

---

## Setup

Install [Node.js](https://nodejs.dev/en/learn/how-to-install-nodejs/) and use **Node.js v16**. Follow the instructions to install `nvm`, a node version manager, which will make switching versions easier.

Install the latest beta version of Connext contracts package in your project.

```bash npm2yarn
npm install @connext/nxtp-contracts@beta
```

---

## Example 1: Hello Chain

In this example, there are two contracts. The `Target` contract on the destination domain will have a greeting that we want to update. The `Source` contract on the origin domain will use `xcall` to execute the update on `Target` by sending encoded calldata.

### Target Contract

```solidity
pragma solidity ^0.8.15;

import {IXReceiver} from "@nxtp/core/connext/interfaces/IXReceiver.sol";

contract HelloTarget is IXReceiver {
  string public greeting;

  /** @notice The receiver function as required by the IXReceiver interface.
    * @dev The Connext bridge contract will call this function.
    */
  function xReceive(
    bytes32 _transferId,
    uint256 _amount,
    address _asset,
    address _originSender,
    uint32 _origin,
    bytes memory _callData
  ) external returns (bytes memory) {
    _updateGreeting(_callData);
  }

  /** @notice Internal function to update the greeting.
    * @param _callData Calldata containing the new greeting.
    */
  function _updateGreeting(bytes memory _callData) internal {
    string memory newGreeting = abi.decode(_callData, (string));
    greeting = newGreeting;
  }
}
```

The goal is to call `_updateGreeting` from the origin domain.

### Source Contract

The source contract initiates the cross-chain operation with `xcall`.

```solidity
pragma solidity ^0.8.15;

import {IConnext} from "@connext/nxtp-contracts/contracts/core/connext/interfaces/IConnext.sol";


/**
 * @title HelloSource
 * @notice Example of cross-domain messaging.
 */
contract HelloSource {
  // The connext contract on the origin domain.
  IConnext public immutable connext;

  constructor(IConnext _connext) {
    connext = _connext;
  }

  /** @notice Updates a greeting variable on the Target contract.
    * @param target Address of the HelloTarget contract.
    * @param destinationDomain The destination domain ID.
    * @param newGreeting New greeting to update to.
    * @param relayerFee The fee offered to relayers. On testnet, this can be 0.
    */
  function updateGreeting (
    address target, 
    uint32 destinationDomain,
    string memory newGreeting,
    uint256 relayerFee
  ) external payable {
    // Encode the data needed for the target contract call.
    bytes memory callData = abi.encode(newGreeting);

    connext.xcall{value: relayerFee}(
      destinationDomain, // _destination: Domain ID of the destination chain
      target,            // _to: address of the target contract
      address(0),        // _asset: use address zero for 0-value transfers
      msg.sender,        // _delegate: address that can revert or forceLocal on destination
      0,                 // _amount: 0 because no funds are being transferred
      0,                 // _slippage: 0 because no funds are being transferred
      callData           // _callData: the encoded calldata to send
    );
  }
}
```

---

## Example 2: Cross-Chain Transfer

This `TransferToken` contract implements a cross-chain token transfer. There's no target contract on the destination side so only one contract is needed.

### TransferToken Contract

```solidity
pragma solidity ^0.8.15;

import {IConnext} from "@nxtp/core/connext/interfaces/IConnext.sol";
import {ERC20} from "@solmate/tokens/ERC20.sol";

/**
 * @title TransferToken
 * @notice Example of a cross-domain token transfer.
 */
contract TransferToken {
  // The connext contract on the origin domain.
  IConnext public immutable connext;

  constructor(IConnext _connext) {
    connext = _connext;
  }

  /**
   * @notice Transfers funds from one chain to another.
   * @param recipient The destination address (e.g. a wallet).
   * @param destinationDomain The destination domain ID.
   * @param tokenAddress Address of the token to transfer.
   * @param amount The amount to transfer.
   * @param relayerFee The fee offered to relayers. On testnet, this can be 0.
   */
  function transfer(
    address recipient,
    uint32 destinationDomain,
    address tokenAddress,
    uint256 amount,
    uint256 relayerFee
  ) external payable {
    ERC20 token = ERC20(tokenAddress);
    require(
      token.allowance(msg.sender, address(this)) >= amount,
      "User must approve amount"
    );

    // User sends funds to this contract
    token.transferFrom(msg.sender, address(this), amount);

    // This contract approves transfer to Connext
    token.approve(address(connext), amount);

    connext.xcall{value: relayerFee}(
      destinationDomain, // _destination: Domain ID of the destination chain
      recipient,         // _to: address receiving the funds on the destination
      tokenAddress,      // _asset: address of the token contract
      msg.sender,        // _delegate: address that can revert or forceLocal on destination
      amount,            // _amount: amount of tokens to transfer
      3,                 // _slippage: the maximum amount of slippage the user will accept in BPS
      ""                 // _callData: empty because we're only sending funds
    );  
  }
}
```

Since funds are going to be routed through Connext's contracts, the user must first approve a spending allowance of the ERC20 to the `TransferToken` contract. The `require` clause checks for this allowance. 

You can use [Etherscan and write](https://goerli.etherscan.io/address/0x7ea6eA49B0b0Ae9c5db7907d139D9Cd3439862a1#writeContract) to the TEST ERC20's `approve` function to do this: 

<img src="/img/developers/TestERC20_Etherscan_Approve.png" alt="TestERC20 Etherscan Approve" width="400"/>

The tokens flow from `User's wallet` => `TokenTransfer` => `ConnextHandler` => `recipient`.

---

## Next Steps

- Try [tracking the status](../guides/xcall-status.md) of an `xcall` after you send it.
- Go through the guide on [authentication](../guides/authentication.md).
- See [how to use callbacks](../guides/xcall-callback.md) to handle execution results back on the origin domain.
- Fork the xApp Starter Kit below and build your own xApp.

[xApp Starter Kit](https://github.com/connext/xapp-starter/)
